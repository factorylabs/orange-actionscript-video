package com.factorylabs.orange.video{	import com.factorylabs.orange.core.IDisposable;	import org.openvideoplayer.events.OvpEvent;	import org.openvideoplayer.net.OvpConnection;	import org.openvideoplayer.net.OvpNetStream;	import org.osflash.signals.Signal;	import flash.display.DisplayObjectContainer;	import flash.events.AsyncErrorEvent;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.events.SecurityErrorEvent;	import flash.media.Video;	/**	 * FVideo provides a robust class for steaming or loading progressive videos.	 * 	 * <p>FVideo incorporates the Open Video Player framework to manage network connections. 	 * <br/><a href="http://openvideoplayer.sourceforge.net/">Open Video Player (OVP)</a></p> 	 * 	 * <hr />	 * <p><a target="_top" href="http://github.com/factorylabs/orange-actionscript/MIT-LICENSE.txt">MIT LICENSE</a></p>	 * <p>Copyright (c) 2004-2010 <a target="_top" href="http://www.factorylabs.com/">Factory Design Labs</a></p>	 * 	 * <p>Permission is hereby granted to use, modify, and distribute this file 	 * in accordance with the terms of the license agreement accompanying it.</p> 	 *	 * @author		Grant Davis	 * @version		0.0.1 :: Mar 1, 2010	 */	public class FVideo 		extends Video			implements IDisposable	{		//-----------------------------------------------------------------		// Variables		//-----------------------------------------------------------------		protected var _holder					:DisplayObjectContainer;		protected var _connection				:OvpConnection;		protected var _stream					:OvpNetStream;		protected var _host						:String;		protected var _url						:String;		protected var _streaming				:Boolean;		protected var _connectionEstablished	:Boolean;				protected var _playing					:Boolean;		protected var _seeking					:Boolean;		protected var _queuedSeekTime			:Number;		protected var _duration					:Number;		protected var _metadata					:Object;		protected var _volume					:Number;		protected var _state					:String;		protected var _useFastStartBuffer		:Boolean;		protected var _playheadTime				:Number;		protected var _userPaused				:Boolean;		protected var _bandwidth				:uint;		protected var _autoDetectBandwidth		:Boolean;		protected var _checkBandwidth			:Boolean;				// event signals		protected var _stateSignal				:Signal;		protected var _connectSignal			:Signal;		protected var _metadataSignal			:Signal;		protected var _playheadUpdateSignal		:Signal;		protected var _completeSignal			:Signal;		protected var _playingSignal			:Signal;		protected var _pauseSignal				:Signal;		protected var _stopSignal				:Signal;		protected var _seekSignal				:Signal;		protected var _bandwidthSignal			:Signal;			//-----------------------------------------------------------------		// States		//-----------------------------------------------------------------		public static const STATE_CONNECTING	:String = "connecting";		public static const STATE_CONNECTED		:String = "connected";		public static const STATE_DISCONNECTED	:String = "disconnected";		public static const STATE_LOADING		:String = "loading";		public static const STATE_BUFFERING		:String = "buffering";		public static const STATE_PLAYING		:String = "playing";		public static const STATE_STOPPED		:String = "stopped";		public static const STATE_PAUSED		:String = "paused";		public static const STATE_SEEKING		:String = "seeking";				//-----------------------------------------------------------------		// Scale Modes		//-----------------------------------------------------------------		public static const SCALE_MAINTAIN_ASPECT_RATIO		:String = "maintainAspectRatio";		public static const SCALE_NONE						:String = "noScale";		public static const SCALE_EXACT_FIT					:String = "exactFit";			//-----------------------------------------------------------------		// Getters/Setters		//-----------------------------------------------------------------		public function get connection() :OvpConnection { return _connection; }		public function get stream() :OvpNetStream { return _stream; }		public function get playing() :Boolean { return _playing; }		public function get state() :String { return _state; }		public function get duration() :Number { return _duration; }		public function get volume() :Number { return _volume; }		public function set volume( $volume :Number ) :void		{			_volume = $volume;			if( _stream ) _stream.volume = _volume;		}		public function get metadata() :Object { return _metadata; }		public function get autoDetectBandwidth() :Boolean { return _autoDetectBandwidth; }		public function set autoDetectBandwidth( $autoDetectBandwidth :Boolean ) :void		{			_autoDetectBandwidth = $autoDetectBandwidth;		}		public function get bandwidth() :uint { return _bandwidth; }		public function get useFastStartBuffer() :Boolean { return _useFastStartBuffer; } // RTMP only		public function set useFastStartBuffer( $useFastStartBuffer :Boolean ) :void		{			_useFastStartBuffer = $useFastStartBuffer;		}		public function get stateSignal() :Signal { return _stateSignal; }		public function get connectSignal() :Signal { return _connectSignal; }		public function get metadataSignal() :Signal { return _metadataSignal; }		public function get playheadUpdateSignal() :Signal { return _playheadUpdateSignal; }		public function get completeSignal() :Signal { return _completeSignal; }		public function get playingSignal() :Signal { return _playingSignal; }		public function get pauseSignal() :Signal { return _pauseSignal; }		public function get stopSignal() :Signal { return _stopSignal; }		public function get seekSignal() :Signal { return _seekSignal; }		public function get bandwidthSignal() :Signal { return _bandwidthSignal; }			//-----------------------------------------------------------------		// Constructor		//-----------------------------------------------------------------			public function FVideo( $holder :DisplayObjectContainer=null, $initObj :Object=null )		{			super();			_holder = $holder;			initialize();			buildSignals();			buildConnection();			if( $holder ) $holder.addChild( this );			if( $initObj ) setProperties( $initObj );		}				//-----------------------------------------------------------------		// API		//-----------------------------------------------------------------				public override function toString() :String 		{			return 'com.factorylabs.orange.video.FVideo';		}				/**		 * RTMP. Connects to a FMS server.		 */		public function connect( $host :String ) :void		{			// TODO: reset previous connection listeners etc?			if ( _streaming ) resetRTMP();			else if ( _stream ) resetHTTP();						if( _stream ) closeStream();			if( _host )			{				// close and rebuild the a new connection if we were				// already connected to another host.				closeConnection();				buildConnection();			}						_connectionEstablished = false;			_checkBandwidth = _autoDetectBandwidth;						if ( $host )			{				_host = $host;				_streaming = true;				prepareRTMPConnection();				_connection.connect( $host );				setState( STATE_CONNECTING );			}		}				/**		 * Progressive. Load but don't play.		 */		public function load( $url :String ) :void		{			_url = $url;			if( _stream ) closeStream();			resetStreamInfo();			prepareHTTPStream();			playStream();			_stream.seek( 0 );			_stream.pause();		}				public function play( $url :String=null ) :Boolean		{			if( $url )			{				resetStreamInfo();								_url = $url;				_playing = true;												if( _streaming )				{					playRTMPStream();				}				else				{					if( _stream ) closeStream();					if( !_connection ) buildConnection();					prepareHTTPStream();					playStream();				}				return true;			}			else if ( _stream )			{				// try to resume the stream if it isnt playing. 				if( !_playing )				{					_playing = true;					_stream.resume();					// if the video is starting up after completely playing, start from beginning.					if ( _state == STATE_STOPPED )					{						_stream.seek( 0 );					}					return true;				}			}			return false;		}				/**		 * Pauses the stream at its current position.		 */		public function pause() :void		{			_playing = false;			_userPaused = true;			if( _stream ) pauseStream();			setState( STATE_PAUSED );			_pauseSignal.dispatch();		}				/**		 * Seeks to a specific position within the stream.		 */		public function seek( $seconds :Number ) :void		{			// constrain seconds within the length of the video.			if( $seconds < 0 ) $seconds = 0;			// ensure we don't seek past what's loaded when playing a progressive video.			if ( !_streaming )			{				var loadedSeconds : Number = ( _stream.bytesLoaded / _stream.bytesTotal ) * this.duration;				if( $seconds > loadedSeconds ) $seconds = loadedSeconds;			}			else if( $seconds >= _duration ) $seconds = _duration;						// if we're already seeking, mark the queued time.			if ( _seeking )			{				_queuedSeekTime = $seconds;				return;			}			_seeking = true;			_stream.seek( $seconds );			setState( STATE_SEEKING );			_seekSignal.dispatch( $seconds );		}		/**		 * Stops the stream and resets the playhead to 0.		 */		public function stop() :void		{			_playing = false;			_userPaused = false;			_seeking = false;			if( _stream )			{				_stream.pause();				_stream.seek( 0 );			}			setState( STATE_STOPPED );			_stopSignal.dispatch();		}		/**		 * Closes both the NetConnection and NetStream.		 * Resets the player for either a new RTMP or Progressive connection.		 */		public function close() :void		{			resetStreamInfo();			if( _connection )			{				resetRTMP();				closeConnection();			}			if( _stream ) 			{				resetHTTP();				closeStream();			}			setState( STATE_DISCONNECTED );		}				public function dispose() :void		{			close();			_stateSignal.removeAll();			_connectSignal.removeAll();			_metadataSignal.removeAll();			_playheadUpdateSignal.removeAll();			_completeSignal.removeAll();			_playingSignal.removeAll();			_pauseSignal.removeAll();			_seekSignal.removeAll();			_stopSignal.removeAll();			_bandwidthSignal.removeAll();						_stream = null;			_connection = null;			_stateSignal = null;			_connectSignal = null;			_metadataSignal = null;			_playheadUpdateSignal = null;			_completeSignal = null;			_playingSignal = null;			_pauseSignal = null;			_seekSignal = null;			_stopSignal = null;			_bandwidthSignal = null;		}		//-----------------------------------------------------------------		// Initializations		//-----------------------------------------------------------------				protected function initialize() :void		{			_volume = 1;			_streaming = false;			_autoDetectBandwidth = true;			_useFastStartBuffer = false;			_connectionEstablished = false;		}				protected function buildSignals() :void		{			_stateSignal 				= new Signal( String );			_connectSignal 				= new Signal();			_metadataSignal 			= new Signal( Object );			_playheadUpdateSignal 		= new Signal( Number );			_completeSignal 			= new Signal();			_playingSignal 				= new Signal();			_pauseSignal 				= new Signal();			_seekSignal 				= new Signal();			_stopSignal 				= new Signal();			_bandwidthSignal			= new Signal( uint );		}				//-----------------------------------------------------------------		// Connection		//-----------------------------------------------------------------				/**		 * Builds the instance of the OvpConnection object.		 * 		 * Override this method to 		 */		protected function buildConnection() :void		{			_connection = new OvpConnection();			_connection.addEventListener( OvpEvent.ERROR, handleError );			_connection.addEventListener( OvpEvent.BANDWIDTH, handleRTMPBandwidth );			_connection.addEventListener( IOErrorEvent.IO_ERROR, handleIOError );			_connection.addEventListener( AsyncErrorEvent.ASYNC_ERROR, handleAsyncError );			_connection.addEventListener( NetStatusEvent.NET_STATUS, handleConnectionNetStatus );			_connection.addEventListener( SecurityErrorEvent.SECURITY_ERROR, handleSecurityError );		}				protected function closeConnection() :void		{			_connection.removeEventListener( OvpEvent.ERROR, handleError );			_connection.removeEventListener( OvpEvent.BANDWIDTH, handleRTMPBandwidth );			_connection.removeEventListener( IOErrorEvent.IO_ERROR, handleIOError );			_connection.removeEventListener( AsyncErrorEvent.ASYNC_ERROR, handleAsyncError );			_connection.removeEventListener( NetStatusEvent.NET_STATUS, handleConnectionNetStatus );			_connection.removeEventListener( SecurityErrorEvent.SECURITY_ERROR, handleSecurityError );			_connection.close();			_connection = null;		}				protected function handleGoodConnect() :void		{			trace( '[FVideo].handleGoodConnect()' );			_connectionEstablished = true;			buildNetStream();			setState( STATE_CONNECTED );			_connectSignal.dispatch();		}		protected function handleConnectionNetStatus( $e :NetStatusEvent ) :void		{			trace( '[FVideo].handleConnectionNetStatus() ' + $e.info['code'] );			switch( $e.info['code'] )			{				case 'NetConnection.Connect.Success':					handleGoodConnect();					break;									case 'NetConnection.Connect.Closed':					trace( '[FVideo] onNetConnectionStatus() :: Disconnected unexpectedly!' );					// TODO: Automatically reconnect?					_connectionEstablished = false;					setState( STATE_DISCONNECTED );					_connection.reconnect();					break;			}		}				protected function handleSecurityError( $e :SecurityErrorEvent ) :void		{			trace( '[FVideo].handleSecurityError() ' + $e.text );		}				protected function handleIOError( $e :IOErrorEvent ) :void		{			trace( '[FVideo].handleIOError() ' + $e.text );		}				protected function handleError( $e :OvpEvent ) :void		{			trace( '[FVideo].handleError() ' );			inspectObject( $e.data );		}				protected function handleAsyncError( $e :AsyncErrorEvent ) :void		{						}				//-----------------------------------------------------------------		// Net Stream		//-----------------------------------------------------------------				protected function resetStreamInfo() :void		{			_duration = 0;			_playing = false;			_seeking = false;			_userPaused = false;			_metadata = null;			_playheadTime = 0;			_queuedSeekTime = NaN;		}				protected function buildNetStream() :void		{			_stream = new OvpNetStream( _connection );			_stream.createProgressivePauseEvents = true;			_stream.progressInterval = this.stage ? int(( 1/this.stage.frameRate )*1000) : 33;			_stream.useFastStartBuffer = ( _streaming ) ? _useFastStartBuffer : false;			_stream.volume = _volume;			_stream.addEventListener( OvpEvent.COMPLETE, handlePlaybackComplete );			_stream.addEventListener( OvpEvent.NETSTREAM_METADATA, handleMetadata );			_stream.addEventListener( OvpEvent.NETSTREAM_CUEPOINT, handleCuePoint );			_stream.addEventListener( OvpEvent.PROGRESS, handleStreamProgress );			_stream.addEventListener( NetStatusEvent.NET_STATUS, handleNetStatus );			this.attachNetStream( _stream );		}				protected function closeStream() :void		{			_stream.removeEventListener( OvpEvent.COMPLETE, handlePlaybackComplete );			_stream.removeEventListener( OvpEvent.NETSTREAM_METADATA, handleMetadata );			_stream.removeEventListener( OvpEvent.NETSTREAM_CUEPOINT, handleCuePoint );			_stream.removeEventListener( OvpEvent.PROGRESS, handleStreamProgress );			_stream.removeEventListener( NetStatusEvent.NET_STATUS, handleNetStatus );			_stream.close();			_stream = null;		}				protected function playStream() :void		{			_stream.play( _url );			setState( STATE_LOADING );		}				private function pauseStream() :void		{			_stream.pause();		}				protected function handleCuePoint( $e : OvpEvent ) :void		{			trace( '[FVideo].handleCuePoint()' );			inspectObject( $e.data );//			_cuePointSignal.dispatch();		}				protected function handleMetadata( $e : OvpEvent ) :void		{			trace( '[FVideo].handleMetadata() ');			inspectObject( $e.data );			_metadata = $e.data;			_metadataSignal.dispatch( _metadata );		}				protected function handleStreamProgress( $e :OvpEvent ) :void		{			if( _playheadTime == _stream.time )			{//				trace( '[FVideo].handleStreamProgress() :: playhead: ' + _playheadTime + ", stream time: " + _stream.time + ", playing: " + _playing + ", isBuffering: " + _stream.isBuffering );				// TODO: See if we need to migrate code for forcing the complete event.								if( _playing && _stream.isBuffering )					setState( STATE_BUFFERING );								return;			}						_playheadTime = _stream.time;						if ( _playing && _stream.bufferLength > _stream.bufferTime ) 			{				setState( STATE_PLAYING );				_playingSignal.dispatch();			}						_playheadUpdateSignal.dispatch( _playheadTime );		}				protected function handlePlaybackComplete( $e : OvpEvent ) :void		{			trace( '[FVideo].handlePlaybackComplete() :: ' + _stream.time );			_playing = false;			setState( STATE_STOPPED );			_completeSignal.dispatch();		}				protected function handleNetStatus( $e :NetStatusEvent ):void		{//			trace( '[FVideo].handleNetStatus() :: ' + $e.info[ 'code' ] );			switch( $e.info[ 'code' ])			{				case "NetStream.Seek.Notify":					// done seeking.					_seeking = false;					if ( !isNaN( _queuedSeekTime ))					{						seek( _queuedSeekTime );						_queuedSeekTime = NaN;					}					// return to a paused state if we were paused and then told to seek. 					else if ( _userPaused )					{						trace( '[FVideo].handleNetStatus() :: Returning to paused state after seek' );						setState( STATE_PAUSED );					}					break;									case "NetStream.Seek.Failed":					trace( "[FVideo] onSeekStatus() \n\tSeek failed to complete." );					break;									case "NetStream.Seek.InvalidTime":					trace( "[FVideo] onSeekStatus() \n\tInvalid seek time specified." );					break;			}		}				//-----------------------------------------------------------------		// Streaming (RTMP) Logic		// TODO: this is only here for easy clicking around.		//-----------------------------------------------------------------				protected function prepareRTMPConnection() :void		{//			_connection.addEventListener( OvpEvent.BANDWIDTH, handleBandwidth );			_connection.addEventListener( OvpEvent.STREAM_LENGTH, handleRTMPStreamLength );		}				protected function resetRTMP() :void		{			_connection.removeEventListener( OvpEvent.STREAM_LENGTH, handleRTMPStreamLength );			_connection.removeEventListener( NetStatusEvent.NET_STATUS, handleRTMPConnectThenPlay );		}				protected function playRTMPStream() :void		{			// request the stream length if we're connected.			if( _connectionEstablished ) 			{				trace( '[FVideo].playRTMPStream(), Connection exists, requesting stream length.' );				_connection.requestStreamLength( _url );			}			// otherwise, wait for the connection to establish then connect.			else 			{				trace( '[FVideo].playRTMPStream(), No connect yet. Waiting for connect...' );				_connection.addEventListener( NetStatusEvent.NET_STATUS, handleRTMPConnectThenPlay );			}		}				protected function handleRTMPConnectThenPlay( $e :NetStatusEvent ) :void		{			if ( $e.info['code'] == 'NetConnection.Connect.Success' )			{				trace( '[FVideo].handleConnectThenPlay()\n\tConnection established. Loading stream...' );				_connection.removeEventListener( NetStatusEvent.NET_STATUS, handleRTMPConnectThenPlay );				_connection.requestStreamLength( _url );			}		}				// TODO: Add logic to auto-initiate a server bandwidth check?		protected function handleRTMPStreamLength( $e :OvpEvent ) :void		{//			trace( '[FVideo].handleStreamLength()' );			_duration = $e.data['streamLength'];			if( _checkBandwidth ) 			{				trace( '[FVideo].handleRTMPStreamLength() :: Bandwidth not set, detecting...' );				_connection.detectBandwidth();			}			else			{				trace( '[FVideo].handleRTMPStreamLength() :: Bandwidth detection not needed. Playing stream.' );				playStream();				if ( _userPaused ) pauseStream();			}		}				protected function handleRTMPBandwidth( $e :OvpEvent ) :void		{			_checkBandwidth = false;			_bandwidth = $e.data['bandwidth'];			trace( '[FVideo].handleRTMPBandwidth() :: bandwidth: ' + _bandwidth );			playStream();			if ( _userPaused ) pauseStream();			_bandwidthSignal.dispatch( _bandwidth );		}				//-----------------------------------------------------------------		// Progressive (HTTP) Logic		//-----------------------------------------------------------------				protected function prepareHTTPStream() :void		{			setState( STATE_CONNECTING );			_connection.connect( null );			_stream.addEventListener( OvpEvent.STREAM_LENGTH, handleHTTPStreamLength );		}				protected function resetHTTP() :void		{			_stream.removeEventListener( OvpEvent.STREAM_LENGTH, handleHTTPStreamLength );		}				protected function handleHTTPStreamLength( $e :OvpEvent ) :void		{			trace( '[FVideo].handleHTTPStreamLength()' );			inspectObject( $e.data );			_duration = $e.data['streamLength']; 		}						//-----------------------------------------------------------------		// Sizing		//-----------------------------------------------------------------				//-----------------------------------------------------------------		// Helper methods		//-----------------------------------------------------------------		private final function setState( $state :String ) :void		{			if( $state != _state )			{				trace( '[FVideo].setState() :: ' + $state );				_state = $state;				_stateSignal.dispatch( _state );			}		}				private function inspectObject( $obj : Object ) :void		{			for( var prop : String in $obj )			{				trace( '\t' + prop + ' = ' + $obj[prop] );			}		}		private final function setProperties( $obj : Object ) :void		{			for( var prop : String in $obj )			{				if( this.hasOwnProperty( prop )) this[ prop ] = $obj[ prop ];				else				{					throw new Error( "The property " + prop + " was not found on " + this.toString());				}			}		}	}}